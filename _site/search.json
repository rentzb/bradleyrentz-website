[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About me",
    "section": "",
    "text": "I am an applied quantitative researcher specializing in education research, sociolinguistics, and data science. I worked at McREL International from 2018‚Äì2025 and was the Applied Research Lead for the Institute of Education Sciences‚Äô Regional Educational Laboratory (REL) Pacific.\nI have a PhD in linguistics from the University of Hawai ªi at MƒÅnoa.\nMy research has focused on variety of topics including teacher preparation in Palau and Gu√•han; college readiness of high school students in Pohnpei, Federated States of Micronesia, Gu√•han, the Republic of the Marshall Islands, and Palau; social-emotional learning of high school student in CNMI; language attitudes on Pohnpei; and topological relations in Pohnpeian.\nOutside of my research, I have led several technical assistance projects on education language policy, Indigenous language instruction, Indigenous culture education, instructional models, systemic change, teacher and principal professional learning, and data-informed decision-making."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "blog/index.html#section",
    "href": "blog/index.html#section",
    "title": "Blog",
    "section": "2025",
    "text": "2025\n\n\n    \n    \n                  \n            February 10, 2025\n        \n        \n            Using USAID data to make fancy world maps with Observable Plot\n\n            \n            \n                \n                \n                    ojs\n                \n                \n                \n                    observable plot\n                \n                \n                \n                    gis\n                \n                \n                \n                    maps\n                \n                \n                \n                    usaid\n                \n                \n            \n            \n\n            Manipulate geographic data, change projections, get live data from a database, and make interactive plots with Observable JS\n            \n            \n            10.59350/c0aep-hp989\n            \n        \n        \n        \n            \n\n        \n    \n    \n\n\nNo matching items"
  },
  {
    "objectID": "blog/2025/02/10/usaid-ojs-maps/index.html",
    "href": "blog/2025/02/10/usaid-ojs-maps/index.html",
    "title": "Using USAID data to make fancy world maps with Observable Plot",
    "section": "",
    "text": "As part of Elon Musk‚Äôs weird Department of Government Efficiency‚Äôs unconstitutional rampage through the federal government, USAID‚Äôs ForeignAssistance.gov was taken offline on January 31, 2025. It reappeared on February 3, but it‚Äôs not clear how long it will be available, especially as USAID is gutted (despite court orders and injunctions to stop).\nI study civil society, human rights, and foreign aid and rely on USAID aid data for several of my research projects, so as a backup, I used Datasette to create a mirror website/API of the entire ForeignAssistance.gov dataset at https://foreignassistance-data.andrewheiss.com/. Everything as of December 19, 2024 is available there, both as a queryable SQL database and as downloadable CSV files.\nI also made a little frontend website with links to each individual dataset. As I built that website, I decided to try recreating the ForeignAssistance.gov dashboard, which had neat interactive maps and tables.\nSince Quarto has native support for Observable JS for interactive work, and since I‚Äôve meant to really dig into Observable and figure out how to make more interactive graphs, I figured I‚Äôd play around with the rescued USAID data.\nSo in this post, I show what I learned about working with geographic data and making pretty maps with Observable Plot,"
  },
  {
    "objectID": "blog/2025/02/10/usaid-ojs-maps/index.html#working-with-map-data",
    "href": "blog/2025/02/10/usaid-ojs-maps/index.html#working-with-map-data",
    "title": "Using USAID data to make fancy world maps with Observable Plot",
    "section": "Working with map data",
    "text": "Working with map data\nGet map data\nObservable Plot uses the d3-geo module behind the scenes to parse and work with map data, and D3 typically works with data formatted as GeoJSON. There are tons of high quality geographic data sources online, like the US Census (they‚Äôve been removing those in the past few weeks), IPUMS NHGIS, IPUMS IHGIS, and the Natural Earth project, and cities and states typically offer GIS data for public sector-related data. These data sources tend to be stored as shapefiles, which are a fairly complex (but standard) format for geographic data that involve multiple files.\nObservable Plot/D3 might be able to work with shapefiles directly, but it‚Äôs nowhere in the documentation. They seem to expect GeoJSON instead. We could hunt around online for GeoJSON data, but‚Äîeven better‚Äîwe can use the {sf} package in R to convert any shapefile-based data into GeoJSON by setting driver = \"GeoJSON\" in sf::st_write(). Here we‚Äôll load two datasets from Natural Earth‚Äî(1) small scale low resolution 1:110m data for mapping the whole world and (2) medium scale 1:50m data for mapping specific regions and countries‚Äîand convert them to GeoJSON files.\n\nlibrary(sf)\nlibrary(rnaturalearth)\n\n# Get low resolution Natural Earth data as map units instead of countries because of France\nworld &lt;- ne_countries(scale = 110, type = \"map_units\")\n\n# Save as geojson for Observable Plot\nst_write(\n  obj = world, \n  dsn = \"ne_110m_admin_0_countries.geojson\", \n  driver = \"GeoJSON\"\n)\n\n# Save medium resolution geojson\nst_write(\n  obj = ne_countries(scale = 50, type = \"countries\"), \n  dsn = \"ne_50m_admin_0_countries.geojson\", \n  driver = \"GeoJSON\"\n)\n\n\n\n\n\n\n\nMaybe skip intermediate saving?\n\n\n\nWe could probably use Quarto‚Äôs special R-to-OJS function ojs_define() and make these R objects directly accessible to OJS without needing to save intermediate files:\n\nojs_define(world = ne_countries(scale = 110, type = \"map_units\"))\n\n‚Ä¶but geographic data is complex and I don‚Äôt know how things like Observable Plot‚Äôs Plot.geo() handle data that‚Äôs not read as GeoJSON. So to keep things simple, I ended up just saving these as GeoJSON. ü§∑‚Äç‚ôÇÔ∏è\n\n\nMaps and projections with Observable Plot\nWe can load these into our document with OJS with FileAttachment():\n\nworld = FileAttachment(\"ne_110m_admin_0_countries.geojson\").json()\nworld_medium = FileAttachment(\"ne_50m_admin_0_countries.geojson\").json()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCheck out the structure of world. It‚Äôs a FeatureCollection with a slot named crs with the projection information and a slot named features with entries for each country. Each country Feature has a slot named properties with columns like name, iso_a3, formal_en, pop_est, and other details.\n\nworld\n\n\n\n\n\n\nTo plot it, we can use the Geo mark:\n\nPlot.plot({\n  marks: [\n    Plot.geo(world)\n  ]\n})\n\n\n\n\n\n\nTo make things look nicer throughout this post, we‚Äôll define some nicer colors for countries and land and ocean from CARTOColors:\n\ncarto_prism = [\n  \"#5F4690\", \"#1D6996\", \"#38A6A5\", \"#0F8554\", \"#73AF48\", \"#EDAD08\", \n  \"#E17C05\", \"#CC503E\", \"#94346E\", \"#6F4070\", \"#994E95\", \"#666666\"\n]\n\n// From R:\n// clr_ocean &lt;- colorspace::lighten(\"#88CCEE\", 0.7)\nclr_ocean = \"#D9F0FF\"\n\n// From CARTOColors Peach 2\nclr_land = \"#facba6\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe‚Äôll make the land be orange-ish, add some thin black borders around the countries, and include a blue background color with Plot.frame():\n\nPlot.plot({\n  marks: [\n    Plot.frame({ fill: clr_ocean }),  \n    Plot.geo(world, { \n      stroke: \"black\", \n      strokeWidth: 0.5, \n      fill: clr_land \n    }) \n  ]\n})\n\n\n\n\n\n\nBuilt-in projections\nTaking a round globe and smashing it on a two-dimensional surface always requires geometric shenanigans to get things flat. We can control how things get flattened by specifying the projection for the map. Here we‚Äôll use the Equal Earth projection (invented in 2018 to show countries and continents at their true relative sizes to each other). Since projections contain relative height and width details, we need to specify a width for the plot now. I arbitrarily chose 1000 pixels here, which is the maximum width‚Äîit should autoshrink in smaller browser windows, and the height should be calculated automatically. Finally, instead of adding the background color with Plot.frame(), we can use Plot.sphere() to get a nicer background that uses the specified projection:\n\nPlot.plot({\n  projection: \"equal-earth\", \n  width: 1000, \n  marks: [\n    Plot.sphere({ fill: clr_ocean }), \n    Plot.geo(world, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\nThe Observable Plot library includes a bunch of common built-in projections:\n\n\n\nviewof projection = Inputs.select(\n  [\"equirectangular\", \"equal-earth\", \"mercator\", \"transverse-mercator\", \"azimuthal-equal-area\", \"gnomonic\"],\n  {value: \"azimuthal-equal-area\", label: \"Projection\"}\n)\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  projection: projection,\n  // width,\n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\nOther projections\nObservable Plot can support any other D3 projection too. There are a whole bunch of projections in the main d3-geo module, and there‚Äôs a separate d3-geo-projection module for dozens of others. My favorite global projection is Robinson (the foundation for Equal Earth), which lives in d3-geo-projection. To use it, we can import the module with require() and then access it with d3_geo_projection.geoRobinson():\n\nd3_geo_projection = require(\"d3-geo-projection\") \n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(), \n  width: 1000,\n  height: 500, \n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFiltering map data and adjusting projections\nRemoving elements\nNow that we have a nice projection, we can tweak the map a little. Antarctica is taking up a big proportion of the southern hemisphere, so we‚Äôll filter it out. The world object that has all the map data keeps each country object inside a features slot:\n\nworld.features\n\n\n\n\n\n\nWe can filter it using Javascript‚Äôs .filter() function. To make sure that the resulting array keeps the geographic-ness of the data and is a FeatureCollection, we need to create a similarly structured object, with type and features slots:\n\nworld_sans_penguins = ({ \n  type: \"FeatureCollection\", \n  features: world.features.filter(d =&gt; d.properties.iso_a3 !== \"ATA\") \n}) \n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 1000,\n  height: 500,\n  marks: [\n    Plot.sphere({ fill: clr_ocean }),\n    Plot.geo(world_sans_penguins, { \n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThat works and Antarctica is gone, as expected, but in reality the map didn‚Äôt actually change that much. Even if we stop using the sphere background and just fill the plot frame, we can see that the area where Antarctica was is still there, it‚Äôs just missing the land itself:\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 1000,\n  height: 500,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }), \n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\nQuick and dirty cheating method: change the width or height\nOne quick and dirty solution is to mess with the dimensions and shrink the height. After some trial and error, 430 pixels looks good:\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 1000,\n  height: 430, \n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\nWhile this works in this case, it‚Äôs not a universal solution. The only reason this works is because Antarctica happens to be at the bottom of the map. When you adjust the height of the plot area, the map itself is anchored to the top. Like, if we set the height to 215, we‚Äôll get just the northern hemisphere:\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 1000,\n  height: 215, \n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\nAs far as I can tell, there‚Äôs no way to anchor the map in any other position. If we filter the map data to only look at one continent, there‚Äôs no easy way to focus on just that continent by adjusting only the width or height options. Here‚Äôs Africa all by itself in a big empty plot area:\n\njust_africa = ({ \n    type: \"FeatureCollection\", \n    features: world.features.filter(d =&gt; d.properties.continent == \"Africa\") \n}) \n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 1000,\n  height: 430, \n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(just_africa, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf we adjust the width or the height, the plot area will be resized with the map anchored in the top left corner so we‚Äôre left with just the northwestern part of Africa (and big empty areas where North America, South America, and Europe would be):\n\nPlot.plot({\n  projection: d3_geo_projection.geoRobinson(),\n  width: 550, \n  height: 215, \n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(just_africa, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\nThat‚Äôs not great, but there are better ways!\nBuilt-in projections and domain settings\nThe official Observable Plot method for fitting the plot window to a specific area of the map is to define a ‚Äúdomain‚Äù for one of the built-in projections to zoom in on specific areas. The documentation shows how to use special functions in d3-geo to create a circle around a point, but you can also pass a GeoJSON object and Plot will use its boundaries for the domain. The built-in projection options also let us control the outside margin of the domain with inset.\nHere‚Äôs the world map without Antarctica with the Equal Earth projection, with the projection resized to fit within the bounds of world_sans_penguins, with 10 pixels of padding around the landmass. Antarctica is gone now and the rest of the map is vertically centered within the plot area:\n\nPlot.plot({\n  projection: { \n    type: \"equal-earth\", \n    domain: world_sans_penguins, \n    inset: 10 \n  }, \n  width: 1000,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\nWe can see what‚Äôs happening behind the scenes if we add Plot.sphere() back in. The rounded globe area is still there, but it‚Äôs shifted down and out of the frame. We‚Äôre essentially panning around and zooming in on the Equal Earth projection:\n\nPlot.plot({\n  projection: {\n    type: \"equal-earth\",\n    domain: world_sans_penguins, \n    inset: 10\n  },\n  width: 1000,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1 }), \n    Plot.sphere({ fill: clr_ocean }), \n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\nPassing a GeoJSON object as the domain is really neat because it makes it straightforward to zoom in on specific areas. For instance, here‚Äôs the complete medium resolution world map zoomed in around the just_africa object, which keeps non-African countries in the Middle East and southern Europe:\n\nPlot.plot({\n  projection: {\n    type: \"equal-earth\",\n    domain: just_africa, \n    inset: 10\n  },\n  width: 600, \n  height: 600, \n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_medium, { \n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\nWe could also extract Africa from the medium resolution world map and plot only that continent, omitting the Middle East and Europe:\n\njust_africa_medium = ({ \n    type: \"FeatureCollection\", \n    features: world_medium.features.filter(d =&gt; d.properties.continent == \"Africa\") \n}) \n\nPlot.plot({\n  projection: {\n    type: \"equal-earth\",\n    domain: just_africa,\n    inset: 10\n  },\n  width: 600,\n  height: 600,\n  marks: [\n    // Use a white background since we don't want to make it look like  \n    // the Sinai peninsula has a coastline  \n    Plot.frame({ fill: \"white\", stroke: \"black\", strokeWidth: 1 }), \n    Plot.geo(just_africa_medium, {  \n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOther projections and .fitExtent()\n\nUnfortunately, it‚Äôs a little bit trickier to set the domain and inset for projections that aren‚Äôt built in to Plot. We can‚Äôt do this:\nPlot.plot({\n  projection: {\n    type: d3_geo_projection.geoRobinson(),\n    domain: world_sans_penguins,\n    inset: 10\n  },\n  ...\n})\nInstead, we need to adjust the size of the projection window itself and build in the inset with d3-geo‚Äôs .fitExtent(). This function takes four arguments in an array like [[x1, y1], [x2, y2]], defining the top left and bottom right corners (in pixels) of a window that is centered in the middle of a given GeoJSON object. Here, for instance, we create a copy of the Robinson projection that has a window around just_africa with a top left corner at (30, 30) and a bottom right corner at (570, 570):\n\ninset_africa = 30\nafrica_map_width = 600\nafrica_map_height = 600\n\nafrica_robinson = d3_geo_projection.geoRobinson()\n  .fitExtent(\n    [[inset_africa, inset_africa],  // Top left\n     [africa_map_width - inset_africa, africa_map_height - inset_africa]],  // Bottom right \n    just_africa\n  )\n\nPlot.plot({\n  projection: africa_robinson,\n  width: africa_map_width,\n  height: africa_map_height,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can use the same approach with individual countries. For extra fun, we‚Äôll fill these countries with distinct colors using Natural Earth‚Äôs mapcolor7 column, which assigns countries one of 7 different colors that don‚Äôt border other countries (so neighboring countries will never be the same color). We‚Äôll also add some labels in the middle of each country.\n\negypt = world_medium.features.find(d =&gt; d.properties.name === \"Egypt\")\n\ninset_egypt = 75\negypt_map_width = 600\negypt_map_height = 600\n\nrobinson_egypt = d3_geo_projection.geoRobinson()\n  .fitExtent(\n    [[inset_egypt, inset_egypt],  // Top left\n     [egypt_map_width - inset_egypt, egypt_map_height - inset_egypt]],  // Bottom right\n    egypt\n  )\n\nPlot.plot({\n  projection: robinson_egypt,\n  width: egypt_map_width,\n  height: egypt_map_height,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_medium, Plot.centroid({\n      fill: d =&gt; d.properties.mapcolor7,\n      stroke: \"black\", \n      strokeWidth: 0.5\n    })),\n    Plot.geo(egypt, { stroke: \"yellow\", strokeWidth: 3 }),\n    Plot.tip(world_medium.features, Plot.centroid({\n      title: d =&gt; d.properties.name, \n      anchor: \"top\",\n      fontSize: 13,\n      fontWeight: \"bold\",\n      textPadding: 3\n    }))\n  ],\n  color: {\n    range: carto_prism\n  }\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe approach works for the whole world_sans_penguins object as well. This addresses our original problem‚Äîhere‚Äôs a world map with the Robinson projection without Antarctica that fills the plot area correctly:\n\ninset_world = 10\nworld_map_width = 1000\nworld_map_height = 450\n\nworld_sans_penguins_robinson = d3_geo_projection.geoRobinson()\n  .fitExtent(\n    [[inset_world, inset_world],\n     [world_map_width - inset_world, world_map_height - inset_world]],\n    world_sans_penguins\n  )\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5,\n      fill: clr_land\n    })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArbitrary areas and .fitExtent()\n\nFor bonus fun, this approach also works for any arbitrary rectangles. For example, we can use OpenStreetMap‚Äôs neat Export tool to pick the top, bottom, left, and right edges of a box that focuses on Western Europe.\n\n\nRectangle around western Europe with OpenStreetMap‚Äôs Export tool\n\nWe can then use those coordinates to create a MultiPoint geometric feature/object, which essentially acts like a rectangular fake country/region that can be used as the domain or extent of the map:\n\ninset_europe = 10\neurope_map_width = 800\neurope_map_height = 800\n\neurope_box = ({\n  type: \"Feature\",\n  geometry: {\n    type: \"MultiPoint\",\n    coordinates: [\n      [-13, 35],  // [left/west, bottom/south] (or bottom left corner)\n      [21, 60]    // [right/east, top/north]   (or top right corner)\n    ]\n  }\n})\n\neurope_robinson = d3_geo_projection.geoRobinson()\n  .fitExtent(\n    [[inset_europe, inset_europe],\n     [europe_map_width - inset_europe, europe_map_height - inset_europe]], \n    europe_box\n  )\n\nPlot.plot({\n  projection: europe_robinson,\n  width: europe_map_width,\n  height: europe_map_height,\n  marks: [\n    Plot.frame({ fill: clr_ocean, stroke: \"black\", strokeWidth: 1 }),\n    Plot.geo(world_medium, Plot.centroid({\n      fill: d =&gt; d.properties.mapcolor9,\n      stroke: \"white\", \n      strokeWidth: 0.25\n    })),\n    Plot.tip(world.features, Plot.centroid({\n      title: d =&gt; d.properties.name, \n      anchor: \"bottom\",\n      fontSize: 13,\n      fontWeight: \"bold\",\n      textPadding: 3\n    }))\n  ],\n  color: {\n    range: carto_prism\n  }\n})"
  },
  {
    "objectID": "blog/2025/02/10/usaid-ojs-maps/index.html#working-with-usaid-data",
    "href": "blog/2025/02/10/usaid-ojs-maps/index.html#working-with-usaid-data",
    "title": "Using USAID data to make fancy world maps with Observable Plot",
    "section": "Working with USAID data",
    "text": "Working with USAID data\nGet USAID data\nTo make it easier to access and filter and manipulate things, I put the rescued data on a Datasette instance, which is nice front-end for an SQLite database. This makes it possible to run SQL queries directly in the browser and generate custom datasets without needing to load the full massive CSV files into R or Python or Stata or whatever.\nFor example, one of the rescued USAID datasets is named us_foreign_aid_country and it contains 22,000+ rows, with data on aid obligations, appropriations, and disbursements starting in 1999.\nIf we want to get a total of all constant USD aid obligations by country in 2023, omitting regional and world totals, we could do something like this with R and {dplyr}:\n\nlibrary(tidyverse)\n\n# Download the raw CSV and put it somewhere\nus_foreign_aid_country &lt;- read_csv(\"us_foreign_aid_country.csv\")\n\nus_foreign_aid_country |&gt;\n  filter(\n    `Fiscal Year` == 2023, \n    `Transaction Type Name` == \"Obligations\",\n    !str_detect(`Country Name`, \"Region\"),\n    `Country Name` != \"World\"\n  ) |&gt;\n  group_by(`Country Code`, `Country Name`, `Region Name`) |&gt;\n  summarize(total_constant_amount = sum(constant_amount)) |&gt;\n  arrange(desc(total_constant_amount))\n#&gt;  A tibble: 176 √ó 4\n#&gt;  Groups:   Country Code, Country Name [176]\n#&gt;   `Country Code` `Country Name`   `Region Name`                total_constant_amount\n#&gt;   &lt;chr&gt;          &lt;chr&gt;            &lt;chr&gt;                                        &lt;dbl&gt;\n#&gt; 1 UKR            Ukraine          Europe and Eurasia                     17193710403\n#&gt; 2 ISR            Israel           Middle East and North Africa            3302860882\n#&gt; 3 JOR            Jordan           Middle East and North Africa            1686862605\n#&gt; 4 EGY            Egypt            Middle East and North Africa            1503609426\n#&gt; 5 ETH            Ethiopia         Sub-Saharan Africa                      1457374911\n#&gt; 6 SOM            Somalia          Sub-Saharan Africa                      1181033990\n#&gt; 7 NGA            Nigeria          Sub-Saharan Africa                      1019947490\n#&gt; 8 COD            Congo (Kinshasa) Sub-Saharan Africa                       990456757\n#&gt; 9 AFG            Afghanistan      South and Central Asia                   886536741\n#&gt; 0 KEN            Kenya            Sub-Saharan Africa                       846303488\n#&gt;  ‚Ñπ 166 more rows\n#&gt;  ‚Ñπ Use `print(n = ...)` to see more rows\n\nOr we could get that data extract directly from the database without needing to load the huge original CSV file. We can run an SQL query like this at the Datasette website:\nSELECT \"Country Code\", \"Country Name\", \"Region Name\", SUM(\"constant_amount\") AS total_constant_amount\n  FROM \"./us_foreign_aid_country\"\n  WHERE \n    \"Fiscal Year\" = '2023' \n    AND \"Transaction Type Name\" = 'Obligations' \n    AND \"Country Name\" NOT LIKE '%Region%' \n    AND \"Country Name\" != \"World\"\n  GROUP BY \"Country Code\", \"Country Name\", \"Region Name\"\n  ORDER BY total_constant_amount DESC;\n\n\nSQL query and results\n\nSince we‚Äôre working with interactive Observable Javascript, we can load that data directly into the browser instead of downloading intermediate CSV files. There‚Äôs a neat Datasette database client for Observable that lets us run SQL queries (there are lots of other clients too, if you want to connect to things like DuckDB, SQLite, MySQL, Snowflake, and so on).\n\nimport { DatasetteClient } from \"@ambassadors/datasette-client\"\n\naid_db = new DatasetteClient(\n  \"https://foreignassistance-data.andrewheiss.com/2025-02-03_foreign-assistance\"\n)\n\nrecipient_countries = await aid_db.sql`\n  SELECT \"Country Code\", \"Country Name\", \"Region Name\", SUM(\"constant_amount\") AS total_constant_amount\n  FROM \"./us_foreign_aid_country\"\n  WHERE \n    \"Fiscal Year\" = '2023' \n    AND \"Transaction Type Name\" = 'Obligations' \n    AND \"Country Name\" NOT LIKE '%Region%' \n    AND \"Country Name\" != \"World\"\n  GROUP BY \"Country Code\", \"Country Name\", \"Region Name\"\n  ORDER BY total_constant_amount DESC;\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThrough the magic of this Datasette client, we now have a pre-summarized dataset to work with!\n\n// I don't want to keep hitting the Datasette server with requests, so I'm \n// cheating and loading a CSV extract instead. It comes from this query: \n// https://foreignassistance-data.andrewheiss.com/2025-02-03_foreign-assistance.csv?sql=SELECT+%22Country+Code%22%2C+%22Country+Name%22%2C+%22Region+Name%22%2C+SUM%28%22constant_amount%22%29+AS+total_constant_amount%0D%0A++FROM+%22.%2Fus_foreign_aid_country%22%0D%0A++WHERE+%22Fiscal+Year%22+%3D+%272023%27+%0D%0A++++AND+%22Transaction+Type+Name%22+%3D+%27Obligations%27+%0D%0A++++AND+%22Country+Name%22+NOT+LIKE+%27%25Region%25%27+%0D%0A++++AND+%22Country+Name%22+%21%3D+%22World%22%0D%0A++GROUP+BY+%22Country+Code%22%2C+%22Country+Name%22%2C+%22Region+Name%22%0D%0A++ORDER+BY+total_constant_amount+DESC%3B&_size=max\nrecipient_countries = await FileAttachment(\"recipient_countries.csv\").csv({ typed: true })\n\n\n\n\n\n\n\nrecipient_countries"
  },
  {
    "objectID": "blog/2025/02/10/usaid-ojs-maps/index.html#connect-usaid-data-to-the-map-data",
    "href": "blog/2025/02/10/usaid-ojs-maps/index.html#connect-usaid-data-to-the-map-data",
    "title": "Using USAID data to make fancy world maps with Observable Plot",
    "section": "Connect USAID data to the map data",
    "text": "Connect USAID data to the map data\nFollowing Observable Plot‚Äôs choropleth tutorial, to show these totals on a map, we need to create a Map object,1 which is like a Python dictionary or an R data frame with two columns, where we have (1) a name that shares a name with something in the geographic data, like an ISO3 country code, and (2) a value with the thing we want to plot.\n1¬†This term is admittedly confusing because it has nothing to do with geographic maps and is instead related to functional programming.\ncountry_totals = new Map(recipient_countries.map(d =&gt; [d[\"Country Code\"], d.total_constant_amount]))\ncountry_totals\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis lets us get specific totals with the .get() method. Here‚Äôs Ukraine, for example:\n\ncountry_totals.get(\"UKR\")\n\n\n\n\n\n\nWe can feed the ISO3 code of each country-level geographic shape into this country_totals object to extract the total amount of aid for each country. We‚Äôll use the Antarctica-free Robinson projection we made earlier, and we‚Äôll remove the ocean fill since we‚Äôll ultimately make this interactive and hoverable:\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d =&gt; country_totals.get(d.properties.iso_a3)\n    }))\n  ]\n})\n\n\n\n\n\n\nImproving the map\nWe have a choropleth! But this is hardly publication worthy. We need to fix a bunch of issues with it.\nFirst, countries that don‚Äôt receive aid don‚Äôt appear in the map. Let‚Äôs add borders to all the countries:\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d =&gt; country_totals.get(d.properties.iso_a3)\n    })),\n    Plot.geo(world_sans_penguins, {  \n      stroke: \"black\",  \n      strokeWidth: 0.5  \n    })  \n  ]\n})\n\n\n\n\n\n\nThe coloring here is gross because of some huge outliers (Ukraine) that make most countries black/dark blue. There‚Äôs also no legend to show what these values are. We can address all of this by adjusting the legend options. We‚Äôll log total aid, include the legend, add a nice label, and use a single-hue coloring scheme with gray for countries without aid:\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d =&gt; country_totals.get(d.properties.iso_a3)\n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5\n    })\n  ],\n  color: {  \n    scheme: \"blues\",  \n    unknown: \"#f2f2f2\",  \n    type: \"log\",   \n    legend: true,  \n    label: \"Total obligations\",  \n  }  \n})\n\n\n\n\n\n\nNext, let‚Äôs make this interactive by turning on hovering tooltips:\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d =&gt; country_totals.get(d.properties.iso_a3),\n      tip: true \n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5\n    })\n  ],\n  color: {\n    scheme: \"blues\",\n    unknown: \"#f2f2f2\",\n    type: \"log\", \n    legend: true,\n    label: \"Total obligations\",\n  }\n})\n\n\n\n\n\n\nThat‚Äôs so cool. Hover over Mexico and you‚Äôll see ‚ÄúTotal obligations 232,214,023‚Äù.\nWe can make this tooltip more informative by including the country name and formatting the amount to show dollars. Instead of using tip: true, we can add the country name as a channel (Observable Plot‚Äôs version of a ggplot aesthetic), and format the tip so that the country name comes first and the total amount is formatted with d3.format():\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d =&gt; country_totals.get(d.properties.iso_a3),\n      channels: { \n        Country: d =&gt; d.properties.name, \n      }, \n      tip: { \n        format: { \n          Country: true, \n          fill: d3.format(\"$,d\") \n        } \n      } \n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5\n    })\n  ],\n  color: {\n    scheme: \"blues\",\n    unknown: \"#f2f2f2\",\n    type: \"log\", \n    legend: true,\n    label: \"Total obligations\",\n  }\n})\n\n\n\n\n\n\nNow hover over Mexico and you‚Äôll see the country name and the amount of aid in dollars.\nFixing labelling issues\nWe have two final super minor issues to address.\nFirst hover over a country that didn‚Äôt receive aid, like the United States or Australia. The total reported aid displays as ‚Äú$NaN‚Äù. That‚Äôs gross. It‚Äôd be nicer if it said something else, like ‚Äú$0‚Äù or ‚ÄúNo aid‚Äù or something more informative.\nTo fix this, we can make a little function that formats the given value as a dollar amount if it‚Äôs an actual value, and formats it as something else if it‚Äôs missing or not a number (like log(0)):\n\nfunction format_aid_total(value) {\n  return value ? d3.format(\"$,d\")(value) : \"No aid\";\n}\n\n\n\n\n\n\nThat works nicely:\n\nformat_aid_total(394023)\n\n\n\n\n\n\n\nformat_aid_total(NaN)\n\n\n\n\n\n\n\n\nThe other problem is in the legend, which uses a logarithmic scale and includes breaks for 10k, 1M, 100M, and 10G, representing $10,000, $1 million, $100 million, and $10 billion in aid.\nThe issue is the $10 billion, which is abbreviated with ‚ÄúG‚Äù.\nThis is happening because d3.format() uses SI (Syst√®me international d‚Äôunit√©s, or International System of Units) values for its numeric formats, which means that it uses SI metric prefixes. Those legend breaks, therefore, actually technically mean this:\n\n10k: 10 kilodollars\n1M: 1 megadollar\n100M: 100 megadollars\n10G: 10 gigadollars\n\nlol, I should start talking about big dollar amounts with these values (‚Äúthe 2022 US federal budget deficit was 1.4 teradollars‚Äù)\nThe first letters of many of these SI prefixes happen to line up with US-style large numbers:\n\nIn the US we already commonly use ‚Äúk‚Äù for thousand\nThe initial ‚Äúm‚Äù in ‚Äúmega‚Äù aligns with ‚Äúmillion‚Äù\nThe initial ‚Äút‚Äù in tera aligns with ‚Äútrillion‚Äù\n\nBut ‚Äúgiga‚Äù doesn‚Äôt align with ‚Äúbillion‚Äù, hence the strange ‚ÄúG‚Äù here for dollar amounts.\nPeople have requested that d3-format include an option for switching the abbreviation from G to B, but the developers haven‚Äôt added it (and probably won‚Äôt). Instead, a common recommended fix is to replace all ‚ÄúG‚Äùs with ‚ÄúB‚Äùs:\n\nnumber_in_billions = 13840918291  // A big number I randomly typed\n\n// Billions of dollars instead of SI-style gigadollars\nd3.format(\"$.4s\")(number_in_billions).replace(\"G\", \"B\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can add format_aid_total() and the .replace(\"G\", \"B\") tweak and fix the labels in our interactive map:\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d =&gt; country_totals.get(d.properties.iso_a3),\n      channels: {\n        Country: d =&gt; d.properties.name,\n      },\n      tip: {\n        format: {\n          Country: true,\n          fill: d =&gt; format_aid_total(d) \n        }\n      }\n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.5\n    })\n  ],\n  color: {\n    scheme: \"blues\",\n    unknown: \"#f2f2f2\",\n    type: \"log\", \n    legend: true,\n    label: \"Total obligations\",\n    tickFormat: d =&gt; d3.format(\"$0.2s\")(d).replace(\"G\", \"B\") \n  }\n})\n\n\n\n\n\n\nSome final tweaks\nWe‚Äôre so close! Just a couple final incredibly minor changes:\n\nWe‚Äôll boost the font size of the tooltip a little and increase the font size of the legend\nWe‚Äôll switch from the built-in ColorBrewer blues palette to show how to use custom gradients, like CARTOColors‚Äôs PurpOr sequential palette\n\n\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d =&gt; country_totals.get(d.properties.iso_a3),\n      channels: {\n        Country: d =&gt; d.properties.name,\n      },\n      tip: {\n        fontSize: 12, \n        format: {\n          Country: true,\n          fill: d =&gt; format_aid_total(d)\n        }\n      }\n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.15\n    })\n  ],\n  color: {\n    // scheme: \"blues\", \n    range: [\"#f9ddda\", \"#f2b9c4\", \"#e597b9\", \"#ce78b3\", \"#ad5fad\", \"#834ba0\", \"#573b88\"], \n    unknown: \"#f2f2f2\",\n    type: \"log\", \n    legend: true,\n    label: \"Total obligations\",\n    tickFormat: d =&gt; d3.format(\"$0.2s\")(d).replace(\"G\", \"B\"),\n    style: { \n      \"font-size\": \"14px\" \n    } \n  }\n})"
  },
  {
    "objectID": "blog/2025/02/10/usaid-ojs-maps/index.html#the-full-game-complete-final-code",
    "href": "blog/2025/02/10/usaid-ojs-maps/index.html#the-full-game-complete-final-code",
    "title": "Using USAID data to make fancy world maps with Observable Plot",
    "section": "The full game: Complete final code",
    "text": "The full game: Complete final code\nThat final interactive map looks great! We could be even fancier with it by adding dropdowns for dynamically grabbing data for different years or different types of amounts (appropriations, allocations, etc.), or even filter by specific regions or countries. But we won‚Äôt.\nThe different colors and data sources we‚Äôve used are scattered throughout this post. To simplify things, here‚Äôs the complete code all in one location. (This chunk doesn‚Äôt actually run, since Observable gets mad if you create a new variable with the same name as one that already exists.)\n\nd3_geo = require(\"d3-geo\")\nd3_geo_projection = require(\"d3-geo-projection\")\n\n// ----------------------------------------------------------------------\n// Map stuff\n// ----------------------------------------------------------------------\nworld = FileAttachment(\"ne_110m_admin_0_countries.geojson\").json()\n\n// Antarctica's ISO3 code is ATA\nworld_sans_penguins = ({\n  type: \"FeatureCollection\",\n  features: world.features.filter(d =&gt; d.properties.iso_a3 !== \"ATA\")\n})\n\ninset_world = 10\nworld_map_width = 1000\nworld_map_height = 450\n\nworld_sans_penguins_robinson = d3_geo_projection.geoRobinson()\n  .fitExtent(\n    [[inset_world, inset_world],\n     [world_map_width - inset_world, world_map_height - inset_world]],\n    world_sans_penguins\n  )\n\n// ----------------------------------------------------------------------\n// Data stuff\n// ----------------------------------------------------------------------\nimport { DatasetteClient } from \"@ambassadors/datasette-client\"\n\naid_db = new DatasetteClient(\n  \"https://foreignassistance-data.andrewheiss.com/2025-02-03_foreign-assistance\"\n)\n\nrecipient_countries = await aid_db.sql`\n  SELECT \"Country Code\", \"Country Name\", \"Region Name\", SUM(\"constant_amount\") AS total_constant_amount\n  FROM \"./us_foreign_aid_country\"\n  WHERE \n    \"Fiscal Year\" = '2023' \n    AND \"Transaction Type Name\" = 'Obligations' \n    AND \"Country Name\" NOT LIKE '%Region%' \n    AND \"Country Name\" != \"World\"\n  GROUP BY \"Country Code\", \"Country Name\", \"Region Name\"\n  ORDER BY total_constant_amount DESC;\n`\n\ncountry_totals = new Map(recipient_countries.map(d =&gt; [d[\"Country Code\"], d.total_constant_amount]))\n\nfunction format_aid_total(value) {\n  return value ? d3.format(\"$,d\")(value) : \"No aid\";\n}\n\n// ----------------------------------------------------------------------\n// Plot stuff\n// ----------------------------------------------------------------------\nPlot.plot({\n  projection: world_sans_penguins_robinson,\n  width: world_map_width,\n  height: world_map_height,\n  marks: [\n    Plot.frame({ stroke: \"black\", strokeWidth: 1} ),\n    Plot.geo(world_sans_penguins, Plot.centroid({\n      fill: d =&gt; country_totals.get(d.properties.iso_a3),\n      channels: {\n        Country: d =&gt; d.properties.name,\n      },\n      tip: {\n        fontSize: 12,\n        format: {\n          Country: true,\n          fill: d =&gt; format_aid_total(d)\n        }\n      }\n    })),\n    Plot.geo(world_sans_penguins, {\n      stroke: \"black\",\n      strokeWidth: 0.15\n    })\n  ],\n  color: {\n    range: [\"#f9ddda\", \"#f2b9c4\", \"#e597b9\", \"#ce78b3\", \"#ad5fad\", \"#834ba0\", \"#573b88\"],\n    unknown: \"#f2f2f2\",\n    type: \"log\", \n    legend: true,\n    label: \"Total obligations\",\n    tickFormat: d =&gt; d3.format(\"$0.2s\")(d).replace(\"G\", \"B\"),\n    style: {\n      \"font-size\": \"14px\" \n    }\n  }\n})"
  }
]